\section{Conclusions}
\label{sec:conclusion}

This report compares Thorntail microservices to monolithic Glassfish Enterprise Java, this does not necessarily mean our comparison between microservices and monolithic systems is fair, but overall it still gives good insight into the differences between the two architectures and our experience working with Thorntail and Glassfish. Since we only had time to create our project using one framework for microservices and one application server for the monolithic application we can’t speak for all microservice technologies and all monolithic technologies it means our experience within these architectures will be highly coherent with the technology and not just the architectures alone. \\

Dividing the system up into several different projects made it easier for everyone to find their own solution and build with the tools they felt most comfortable with, it made it easier to assign people to different roles such as frontend developer, database administrator and backend developer. It also changed the way we communicate as we no longer cared about the technology and dependencies the other teams had used in their project as long as we all stayed with the same communication methods, this meant that we would ask more questions like “Can you give me an example request for how to create a new user?” instead of “How do you create a new user?”, the questions may look pretty similar, but the answer to the first question results in an example answer, whereas the second question often resulted in being given the name of the source file where we create new users.\\

Thorntail has a lot easier initial setup and are easier to deploy compared to the Glassfish server, this is most likely due to the fact that microservices require you to go through the initial setup multiple times and whenever you want to deploy the entire application you have to deploy every single service once each which means that microservice frameworks are forced to make this experience as fluent and easy as possible. Glassfish was a lot harder to initially set up, configure and deploy, but monolithic applications only have to do the initial setup once and deploy much less frequently so the aspect is much less important in this kind of application.\\

Microservices have longer response times than monolithic applications, this is due to overhead and connection times of each service as they all have to communicate together to perform the tasks the client asks for, this means that a single request from a client can result in the server sending out several different requests to different services which then has to wait for a reply from the services before it can then reply to the client. A monolithic system will simply do all of these actions internally which means no overhead and no additional connection times.\\

The final conclusion from this project is that microservices are a great way to divide up large enterprise systems into much smaller and more manageable projects that can be easily set up, configured, deployed and tested, but it’s not always worth all the extra planning and required monitoring when developing smaller systems like the one in our project, but it can still be worth using microservice technology and frameworks even if you’re not going to follow the microservice architecture just simply because of the simplicity in configuration and deployment. This means that smaller systems and projects should use microservice technology if possible, but not necessarily follow the architecture.\\
